

// workflow d'enregistrement d'un tournois en backend depuis le jeu


// route creation tournois
creer un nouveau tournois en db lorsque le matchmaking est termine
(
    -> tournamentTitle
    -> userId               (id of the tournament creator)
    -> participantsList     (include tournament creator if participate)
        {
            userId      number (-1 user guest : -2 AI (si elle est autorisee en tournois) )
            alias       String
        }
)


// route usuelle pour enregistrer un match
mettre a jour la db a la fin de chaque match du tournois
{
    winnerId            number (-1 user guest : -2 AI)
    loserId             number ( idem )
    scoreWinner         number
    scoreLoser
    duration            number (seconds)
    tournamentId        number ( si c'est un tournois )
}


lorsque le tournois est termine:
// route pour enregister un tournois termine
{
    tournamentId        number
    participantsList {
        userId
        finalRank       number
    }
}


creer un match:

route: POST /api/match/register

headers: {
    'x-game-secret': '${GAME_BACKEND_SECRET}'
}

Body: MatchData
{
    winnerId?:      number | undefined,
    winnerLevel?:   OPPONENT_LEVEL| string | undefined,
    loserId?:       number | undefined,
    loserLevel?:    OPPONENT_LEVEL | string | undefined,
    scoreWinner:    number,
    scoreLoser:     number,
    duration:       number,
    tournamentId?:  number | undefined,
}
/*
    -> winnerId et loserId sont les ID des joueurs qui ont termines le match
    -> si un joueur joue contre une IA ou que l'un ou les deux joueurs sont guest
        alors les id des guests ou de l'IA (winner ou loser selon le resultat) sont undefined
    -> les types MatchData et OPPONENT_LEVEL sont definis dans typescript/types/match.types.d.ts

    -> si le match fait parti d'un tournois alors specifier tournamentId sinon undefined
*/